<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Alien Menu ‚Äî Escape Room Kiosk</title>
<style>
  :root { --border:#ddd; --ink:#000; --muted:#777; --card:#f7f7f7; }
  html,body {
    margin:0; padding:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:#fff;
    color:#000;
  }
  main { padding:16px; max-width:1100px; margin:auto; }
  h2 { margin: 8px 0 12px; }
  #stage { position:relative; }
  #cam, #preview, #overlay {
    width:100%;
    max-height:60vh;
    object-fit:contain;
    border-radius:12px;
    background:#000;
  }
  #overlay {
    position:absolute;
    left:0; top:0;
    pointer-events:none;
  }
  .row {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin:10px 0;
    align-items:center;
  }
  button {
    padding:10px 14px;
    border-radius:10px;
    border:1px solid #999;
    background:#fff;
    cursor:pointer;
    font-size:16px;
  }
  input[type=file] {
    font-size:14px;
  }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
  }
  .banner {
    background:#eef8d6;
    padding:8px 12px;
    border-left:4px solid #79a200;
    border-radius:8px;
    margin:8px 0;
    font-size:14px;
  }
  .panel {
    background:#fafafa;
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px;
    font-size:13px;
  }
  .kv {
    display:grid;
    grid-template-columns: 140px 1fr;
    gap:6px 10px;
    align-items:center;
  }
  .hint {
    color:#666;
    font-size:12px;
    margin-top:-6px
  }
</style>
</head>
<body>
<main>
  <div class="banner" id="status">‚è≥ waiting for camera‚Ä¶</div>
  <h2>Galactic Tasting Menu ‚Äî New for Upcoming Harvest!</h2>

  <div id="stage">
    <video id="cam" playsinline muted></video>
    <img id="preview" alt="snapshot preview" style="display:none"/>
    <canvas id="overlay"></canvas>
  </div>
  <div class="hint">Line everyone up, get faces in frame, then Snap.</div>

  <div class="row">
    <button id="start">Start Camera</button>
    <button id="snap">Snap Photo</button>
    <input type="file" id="file" accept="image/*"/>
    <button id="make">Make PDF + Code</button>
    <label style="font-size:14px;">
      <input type="checkbox" id="dbg" checked> Debug overlay
    </label>
  </div>

  <div class="panel">
    <div style="font-weight:600; margin-bottom:6px">Detection debug</div>
    <div class="kv">
      <div>Image (w√óh)</div><div><span id="dims">‚Äî</span></div>
      <div>Faces found</div><div><span id="faces">‚Äî</span></div>
      <div>Detector</div><div><span id="loader">Cloud Run ‚Üí Vision API</span></div>
    </div>
  </div>

  <div class="row" style="font-size:14px;">
    <div>RAW digits: <span id="raw" class="mono">‚Äî</span></div>
    <div>Offset: <span id="off" class="mono">‚Äî</span></div>
    <div>Final Lock: <span id="lock" class="mono"><b>86753</b></span></div>
  </div>
</main>

<!-- pdf-lib for PDF export -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

<script>
/*** 1. YOUR CLOUD RUN URL HERE ***/
const CLOUD_FUNCTION_URL = "https://alien-face-service-791433334355.us-east4.run.app/detectFaces";

/*** 2. Puzzle / menu config ***/
const LOCK_CODE_5 = 86753; // this is your physical lock code
const LOCK_DIGITS = String(LOCK_CODE_5).padStart(5,'0').split('').map(d=>parseInt(d,10));
const MAX_SLOTS   = 8;              // max faces we keep
const WHOLE_MIN   = 80000, WHOLE_MAX = 220000; // calorie range for "whole body"

const SAVORY_NAMES = [
  "sweet","tangy","smoky","zesty","umami",
  "peppery","citrusy","herbal","earthy","bright"
];

const CLASS_TITLES = [
  "Feeder Humanoid","Commercial Feeder","Humanoid Rare Stock",
  "Choice Stock","Prime Stock","Select Stock",
  "Market Class","Premium Consignment"
];

const MEAT_DESCRIPTORS = [
  "tender with marbled highlights",
  "fine-grained and evenly marbled",
  "velvety texture, classic marbling",
  "hearty cut with rich marbling",
  "silky finish and subtle marbling",
  "firm bite with balanced marbling",
  "delicate weave with faint marbling",
  "robust profile, well-defined marbling",
  "mellow texture with gentle marbling",
  "supple grain and bright marbling"
];

/*** 3. DOM refs ***/
const statusEl = document.getElementById('status');
const video    = document.getElementById('cam');
const preview  = document.getElementById('preview');
const overlay  = document.getElementById('overlay');
const startBtn = document.getElementById('start');
const snapBtn  = document.getElementById('snap');
const fileIn   = document.getElementById('file');
const makeBtn  = document.getElementById('make');
const dbgOn    = document.getElementById('dbg');

const dimsEl   = document.getElementById('dims');
const facesEl  = document.getElementById('faces');

const rawEl    = document.getElementById('raw');
const offEl    = document.getElementById('off');
const lockEl   = document.getElementById('lock');
lockEl.textContent = String(LOCK_CODE_5).padStart(5,'0');

/*** 4. State ***/
let snapshotImg = null;

/*** 5. Helpers ***/
function statusMsg(m){ statusEl.textContent = m; console.log("[status]",m); }
function setDims(w,h){ dimsEl.textContent = `${w}√ó${h}`; }
function setFaces(n){ facesEl.textContent = String(n); }

function drawBoxes(rects, imgEl){
  if (!dbgOn.checked){
    overlay.width=0; overlay.height=0;
    return;
  }
  const W = imgEl.naturalWidth || imgEl.width;
  const H = imgEl.naturalHeight || imgEl.height;

  // whichever is currently displayed (preview after snap OR live video)
  const baseEl = (preview.style.display==='block') ? preview : video;
  const dispW = baseEl.clientWidth || baseEl.videoWidth || W;
  const dispH = baseEl.clientHeight || baseEl.videoHeight || H;

  overlay.width  = dispW;
  overlay.height = dispH;

  const scaleX = dispW / W;
  const scaleY = dispH / H;

  const ctx = overlay.getContext('2d');
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(50,200,80,.9)';
  ctx.font='14px ui-monospace';
  ctx.fillStyle='rgba(0,0,0,.4)';

  rects.forEach((r,i)=>{
    const x=r.x*scaleX, y=r.y*scaleY, w=r.w*scaleX, h=r.h*scaleY;
    ctx.strokeRect(x,y,w,h);
    ctx.fillRect(x,y-18, 38, 18);
    ctx.fillStyle='#fff';
    ctx.fillText(`#${i+1}`, x+4, y-5);
    ctx.fillStyle='rgba(0,0,0,.4)';
  });
}

/*** 6. Camera + file load ***/
startBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment',
        width:  { ideal: 1280 },
        height: { ideal: 1280 }
      },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    preview.style.display='none';
    video.style.display='block';
    overlay.style.display='block';
    statusMsg('üé• camera ready');
  } catch(e){
    console.error(e);
    alert('Camera blocked. Use HTTPS or localhost on the device.');
  }
};

snapBtn.onclick = () => {
  if (!video.srcObject) return;
  const c = document.createElement('canvas');
  const W = video.videoWidth;
  const H = video.videoHeight;
  c.width = W;
  c.height = H;
  c.getContext('2d').drawImage(video,0,0,W,H);
  preview.src = c.toDataURL('image/jpeg',0.95);

  snapshotImg = new Image();
  snapshotImg.onload = ()=>{
    setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
  };
  snapshotImg.src = preview.src;

  video.style.display='none';
  preview.style.display='block';
};

fileIn.onchange = e => {
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    const c = document.createElement('canvas');
    c.width  = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext('2d').drawImage(img,0,0);
    preview.src = c.toDataURL('image/jpeg',0.95);

    snapshotImg = new Image();
    snapshotImg.onload = ()=>{
      setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
    };
    snapshotImg.src = preview.src;

    video.style.display='none';
    preview.style.display='block';
  };
  img.src = url;
};

/*** 7. Send photo to Cloud Run for face boxes ***/
async function detectFacesCloud(imgEl){
  if (!CLOUD_FUNCTION_URL){
    throw new Error("CLOUD_FUNCTION_URL not set.");
  }

  const base64Data = await imageToBase64NoPrefix(imgEl);

  const res = await fetch(CLOUD_FUNCTION_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ imageBase64: base64Data })
  });

  if (!res.ok){
    const t = await res.text();
    console.error("Cloud Run error", res.status, t);
    throw new Error("Cloud Run call failed");
  }

  const json = await res.json();
  const faces = (json.faces || []).slice();
  faces.sort((a,b)=>a.x-b.x);
  return faces;
}

function imageToBase64NoPrefix(imgEl){
  return new Promise(resolve=>{
    const c = document.createElement('canvas');
    const w = imgEl.naturalWidth  || imgEl.width;
    const h = imgEl.naturalHeight || imgEl.height;
    c.width = w;
    c.height = h;
    c.getContext('2d').drawImage(imgEl,0,0,w,h);
    const dataUrl = c.toDataURL('image/jpeg',0.95);
    const base64 = dataUrl.split(',')[1];
    resolve(base64);
  });
}

/*** 8. The main pipeline button ***/
makeBtn.onclick = async () => {
  try {
    await runPipeline();
  } catch(e){
    console.error(e);
    alert("Pipeline error (see console).");
  }
};

async function runPipeline(){
  if (!snapshotImg){
    alert("Take a photo or choose one first.");
    return;
  }
  await snapshotImg.decode();

  statusMsg("üîç detecting faces‚Ä¶");
  let faces = [];
  try {
    faces = await detectFacesCloud(snapshotImg);
  } catch(e){
    console.error("detectFacesCloud error", e);
  }

  if (!faces || !faces.length){
    statusMsg("‚ö†Ô∏è 0 faces ‚Äî fallback boxes");
    const w=snapshotImg.naturalWidth,h=snapshotImg.naturalHeight;
    const cw=Math.floor(w*0.22),ch=Math.floor(h*0.28);
    const cy=Math.floor((h-ch)/2.2);
    faces=[
      {x:Math.floor(w*0.18),y:cy,w:cw,h:ch},
      {x:Math.floor(w*0.60),y:cy,w:cw,h:ch}
    ];
  } else {
    statusMsg(`üë§ faces: ${faces.length}`);
  }

  drawBoxes(faces, snapshotImg);
  setFaces(faces.length);

  // Only keep up to MAX_SLOTS people
  const kept = faces.slice(0, MAX_SLOTS);

  // Crop each head+shoulders
  const crops = kept.map(r => cropCentered(snapshotImg,r));

  // Build menu slot objects
  const slots = crops.map((c,i)=>{
    const seed = detSeed(c.rect, snapshotImg);
    const P = WHOLE_MIN + (seed % (WHOLE_MAX - WHOLE_MIN + 1));
    return {
      img: c.image,
      posX: c.rect.x,
      P,
      classTitle: CLASS_TITLES[i % CLASS_TITLES.length],
      meatDesc: MEAT_DESCRIPTORS[(seed+i) % MEAT_DESCRIPTORS.length],
      savoryDigit: 0
    };
  });

  // Order by Potential Calories ascending
  const ordered = slots.sort((a,b)=> a.P===b.P ? a.posX-b.posX : a.P-b.P);

  // Assign savory digits so final code is always 86753,
  // but we do NOT display the digit next to Savory factor anymore.
  const n = ordered.length;
  let digits = [];
  if (n>=5){
    digits = Array(n-5).fill(0).concat(LOCK_DIGITS);
  } else {
    digits = LOCK_DIGITS.slice(5-n);
  }
  for (let i=0;i<n;i++) ordered[i].savoryDigit = digits[i];

  // Compute raw and offset for the puzzle math display
  const rawInt = parseInt(digits.join(''),10);
  const rawStr = digits.join('');
  rawEl.textContent = rawStr;
  const offset = (LOCK_CODE_5 - rawInt + 100000) % 100000;
  const offsetStr = String(offset).padStart(5,'0');
  offEl.textContent = offsetStr;

  // Build poster canvas
  const poster = await drawPoster(ordered, offsetStr);

  // Generate PDF or fallback print
  try {
    const { PDFDocument } = PDFLib;
    if (!PDFDocument) throw new Error("no pdf-lib");
    const pdfBytes = await canvasToPdfBytes(poster);
    const blob = new Blob([pdfBytes], {type:"application/pdf"});
    const dl = document.createElement("a");
    dl.href = URL.createObjectURL(blob);
    dl.download = "menu_current.pdf";
    dl.click();
  } catch(e){
    console.warn("PDF fallback", e);
    const w = window.open();
    const url = poster.toDataURL("image/png");
    w.document.write('<img src="'+url+'" style="width:100%">');
    w.document.close();
    w.focus();
    w.print();
  }
}

/*** 9. Cropping, layout, PDF helpers ***/
function cropCentered(imgEl, faceRect){
  // expand around face to include shoulders
  const cx = faceRect.x + faceRect.w/2;
  const cy = faceRect.y + faceRect.h/2;
  const newW = faceRect.w * 2.0;
  const newH = faceRect.h * 2.2;
  const x = Math.max(0, Math.floor(cx - newW/2));
  const y = Math.max(0, Math.floor(cy - newH*0.65));
  const w = Math.floor(Math.min(newW, (imgEl.naturalWidth||imgEl.width) - x));
  const h = Math.floor(Math.min(newH, (imgEl.naturalHeight||imgEl.height) - y));

  const c = document.createElement('canvas');
  c.width = Math.max(1,w);
  c.height = Math.max(1,h);
  c.getContext('2d').drawImage(imgEl,x,y,w,h,0,0,c.width,c.height);
  return { image:c, rect:{x,y,w,h} };
}

function detSeed(rect,imgEl){
  // deterministic-ish number so same person ‚Üí same calories each run
  const mix=(h,x)=>(((h^x)>>>0)*16777619)>>>0;
  let h=0x811c9dc5>>>0;
  h=mix(h,rect.x|0);
  h=mix(h,rect.y|0);
  h=mix(h,rect.w|0);
  h=mix(h,rect.h|0);
  h=mix(h,(imgEl.naturalWidth|0));
  h=mix(h,(imgEl.naturalHeight|0));
  return h>>>0;
}

async function drawPoster(slots,offsetStr){
  // Layout: 2 columns of "cards"
  const W=2000, margin=80, cols=2, gapX=28, gapY=32;
  const boxH=520, textAreaH=220, cardH=boxH+textAreaH+100;
  const rows=Math.ceil(slots.length/cols);
  const H=Math.max(2400, margin+rows*(cardH+gapY)+120);
  const cellW=(W-margin*2-gapX*(cols-1))/cols;

  const c=document.createElement('canvas');
  c.width=W; c.height=H;
  const ctx=c.getContext('2d');

  // background
  ctx.fillStyle='#fff';
  ctx.fillRect(0,0,W,H);

  // title
  ctx.fillStyle='#000';
  ctx.font='bold 72px system-ui';
  ctx.fillText('Galactic Tasting Menu ‚Äî New for Upcoming Harvest!', margin, margin+10);

  let top=margin+70, idx=0;
  for(let r=0;r<rows;r++){
    let left=margin;
    for(let col=0; col<cols; col++){
      if(idx>=slots.length) break;
      const s=slots[idx++];

      // card background
      ctx.fillStyle='#f7f7f7';
      roundRect(ctx,left,top,cellW,cardH,22);
      ctx.fill();

      // class title
      ctx.fillStyle='#000';
      ctx.font='bold 32px system-ui';
      drawWrapped(ctx, s.classTitle, left+24, top+46, cellW-48, 34);

      // head/shoulders image box
      const img=s.img;
      const boxW=cellW-40, boxY=top+80;
      const scale=Math.min(boxW/img.width, boxH/img.height);
      const w2=img.width*scale, h2=img.height*scale;
      ctx.drawImage(img, left+20+(boxW-w2)/2, boxY+(boxH-h2)/2, w2, h2);

      // lot line (renamed, still shows title as requested)
      ctx.font='bold 34px system-ui';
      drawWrapped(ctx, `Lot: ${s.classTitle}`, left+24, boxY+boxH+48, cellW-48, 34);

      // cut description
      ctx.font='30px system-ui';
      drawWrapped(ctx,
        `Cut: ${s.meatDesc}`,
        left+24, boxY+boxH+90, cellW-48, 30
      );

      // savory factor (NO digit shown here anymore)
      drawWrapped(ctx,
        `Savory factor: ${SAVORY_NAMES[s.savoryDigit]}`,
        left+24, boxY+boxH+126, cellW-48, 30
      );

      // potential calories
      drawWrapped(ctx,
        `Potential Calories (whole): ${fmtNum(s.P)}`,
        left+24, boxY+boxH+162, cellW-48, 30
      );

      left += cellW + gapX;
    }
    top += cardH + gapY;
  }

  // footer line with offset
  ctx.fillStyle='#777';
  ctx.font='26px ui-monospace';
  ctx.fillText(`Calibration: Nebula Offset ${offsetStr}`, margin, H - margin);

  return c;
}

function drawWrapped(ctx,text,x,y,maxWidth,lineHeight){
  const words=text.split(' ');
  let line='', yy=y;
  for(let n=0;n<words.length;n++){
    const test = line? line+' '+words[n] : words[n];
    const w=ctx.measureText(test).width;
    if(w>maxWidth && n>0){
      ctx.fillText(line,x,yy);
      line=words[n];
      yy+=lineHeight;
    } else {
      line=test;
    }
  }
  if(line) ctx.fillText(line,x,yy);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function fmtNum(n){
  return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

async function canvasToPdfBytes(canvas){
  const { PDFDocument } = PDFLib;
  const pdf = await PDFDocument.create();
  const page = pdf.addPage([canvas.width, canvas.height]);
  const pngBytes = await new Promise(res=>canvas.toBlob(
    b=>b.arrayBuffer().then(res), 'image/png'
  ));
  const png = await pdf.embedPng(pngBytes);
  page.drawImage(png,{x:0,y:0,width:canvas.width,height:canvas.height});
  return await pdf.save();
}
</script>
</body>
</html>
