<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Alien Menu ‚Äî Escape Room Kiosk</title>
<style>
  :root { --border:#ddd; --ink:#000; --muted:#777; --card:#f7f7f7; }
  html,body {
    margin:0; padding:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:#fff;
    color:#000;
  }
  main { padding:16px; max-width:1100px; margin:auto; }
  h2 { margin: 8px 0 12px; }
  #stage {
    position:relative;
  }
  #cam {
    background:#000;
    width:100%;
    max-height:60vh;
    object-fit:cover;
    border-radius:12px;
    display:block;
  }
  #preview {
    background:#000;
    width:100%;
    max-height:60vh;
    object-fit:contain;
    border-radius:12px;
    display:none;
  }
  .row {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin:10px 0;
    align-items:center;
  }
  button {
    padding:10px 14px;
    border-radius:10px;
    border:1px solid #999;
    background:#fff;
    cursor:pointer;
    font-size:16px;
  }
  input[type=file] {
    font-size:14px;
  }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
  }
  .banner {
    background:#eef8d6;
    padding:8px 12px;
    border-left:4px solid #79a200;
    border-radius:8px;
    margin:8px 0;
    font-size:14px;
    word-break: break-word;
  }
  .panel {
    background:#fafafa;
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px;
    font-size:13px;
  }
  .kv {
    display:grid;
    grid-template-columns: 140px 1fr;
    gap:6px 10px;
    align-items:center;
  }
  .hint {
    color:#666;
    font-size:12px;
    margin-top:-6px
  }
</style>
</head>
<body>
<main>
  <div class="banner" id="status">‚è≥ waiting for camera‚Ä¶</div>
  <h2>Galactic Tasting Menu ‚Äî New for Upcoming Harvest!</h2>

  <div id="stage">
    <video id="cam" playsinline muted></video>
    <img id="preview" alt="snapshot preview"/>
  </div>
  <div class="hint">Line everyone up, fill the frame, then Snap.</div>

  <div class="row">
    <button id="start">Start Camera</button>
    <button id="snap">Snap Photo</button>
    <input type="file" id="file" accept="image/*"/>
    <button id="make">Make PDF + Code</button>
  </div>

  <div class="panel" style="font-size:13px;">
    <div class="kv">
      <div>Image (w√óh)</div><div><span id="dims">‚Äî</span></div>
      <div>Faces found</div><div><span id="faces">‚Äî</span></div>
      <div>Detector</div><div>Cloud Run ‚Üí Vision API</div>
    </div>
  </div>

  <div class="row" style="font-size:14px;">
    <div>RAW digits: <span id="raw" class="mono">‚Äî</span></div>
    <div>Offset: <span id="off" class="mono">‚Äî</span></div>
    <div>Final Lock: <span id="lock" class="mono"><b>86753</b></span></div>
  </div>
</main>

<!-- pdf-lib for PDF export -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

<script>
/*** CONFIG ***/
const CLOUD_RUN_BASE = "https://alien-face-service-791433334355.us-east4.run.app";
const CLOUD_FUNCTION_URL = CLOUD_RUN_BASE + "/detectFaces";
const SIGNED_URL_ENDPOINT = CLOUD_RUN_BASE + "/getUploadUrl";

const LOCK_CODE_5 = 86753; // physical lock code (5 digits)
const LOCK_DIGITS = String(LOCK_CODE_5).padStart(5,'0').split('').map(d=>parseInt(d,10));

// max faces on menu poster (we'll cap at 8)
const MAX_SLOTS   = 8;

// Potential Calories (whole body) range
const WHOLE_MIN   = 80000;
const WHOLE_MAX   = 220000;

// flavor labels used for "Savory factor"
const SAVORY_NAMES = [
  "sweet","tangy","smoky","zesty","umami",
  "peppery","citrusy","herbal","earthy","bright"
];

// stock titles
const CLASS_TITLES = [
  "Feeder Humanoid","Commercial Feeder","Humanoid Rare Stock",
  "Choice Stock","Prime Stock","Select Stock",
  "Market Class","Premium Consignment"
];

// nice / premium cut language pool
const CUT_PREMIUM = [
  "tender with marbled highlights",
  "fine-grained and evenly marbled",
  "velvety texture and balanced richness",
  "hearty cut with deep, developed flavor",
  "silky finish, smooth bite",
  "supple grain and well-rounded body flavor",
  "mellow body texture, easy carving",
  "full profile and satisfying density",
  "rich-bodied, classic table cut",
  "stable house cut with predictable yield"
];

// lower quality / stew / filler cut pool
const CUT_LOW = [
  "chewy filler meat, bulk-grade protein",
  "dense frame cut, best simmered for hours",
  "workable stew stock, reliable mass",
  "tough body sections, economical in volume",
  "slow-braise material, pantry extender",
  "utility trim cut, broth-friendly portions",
  "assertive chew, thrifty slow-cook potential",
  "marrow-forward frame meat for group stew",
  "hearty bone-adjacent texture, communal pot use",
  "rugged cut, recommended for stew service"
];

/*** DOM refs ***/
const statusEl = document.getElementById('status');
const video    = document.getElementById('cam');
const preview  = document.getElementById('preview');
const startBtn = document.getElementById('start');
const snapBtn  = document.getElementById('snap');
const fileIn   = document.getElementById('file');
const makeBtn  = document.getElementById('make');

const dimsEl   = document.getElementById('dims');
const facesEl  = document.getElementById('faces');

const rawEl    = document.getElementById('raw');
const offEl    = document.getElementById('off');
const lockEl   = document.getElementById('lock');
lockEl.textContent = String(LOCK_CODE_5).padStart(5,'0');

/*** State ***/
let snapshotImg = null;

/*** Helpers ***/
function statusMsg(m){
  statusEl.textContent = m;
  console.log("[status]", m);
}
function setDims(w,h){ dimsEl.textContent = `${w}√ó${h}`; }
function setFaces(n){ facesEl.textContent = String(n); }

/*** CAMERA / FILE LOAD ***/
startBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment',
        width:  { ideal: 1280 },
        height: { ideal: 1280 }
      },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    preview.style.display='none';
    video.style.display='block';
    statusMsg('üé• camera ready');
  } catch(e){
    console.error("getUserMedia error", e);
    alert('Camera blocked. Use HTTPS or localhost on the device.');
  }
};

snapBtn.onclick = () => {
  if (!video.srcObject) {
    console.warn("snap: no video stream");
    return;
  }
  const c = document.createElement('canvas');
  const W = video.videoWidth;
  const H = video.videoHeight;
  c.width = W;
  c.height = H;
  c.getContext('2d').drawImage(video,0,0,W,H);
  preview.src = c.toDataURL('image/jpeg',0.95);

  snapshotImg = new Image();
  snapshotImg.onload = ()=>{
    setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
  };
  snapshotImg.src = preview.src;

  video.style.display='none';
  preview.style.display='block';
};

fileIn.onchange = e => {
  const f = e.target.files[0];
  if(!f) {
    console.warn("file input: no file");
    return;
  }
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    const c = document.createElement('canvas');
    c.width  = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext('2d').drawImage(img,0,0);
    preview.src = c.toDataURL('image/jpeg',0.95);

    snapshotImg = new Image();
    snapshotImg.onload = ()=>{
      setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
    };
    snapshotImg.src = preview.src;

    video.style.display='none';
    preview.style.display='block';
  };
  img.src = url;
};

/*** CORE HELPERS NEEDED EARLY ***/

// expand a face box to include shoulders and crop that region
function cropCentered(imgEl, faceRect){
  const cx = faceRect.x + faceRect.w/2;
  const cy = faceRect.y + faceRect.h/2;
  const newW = faceRect.w * 2.0;
  const newH = faceRect.h * 2.2;
  const x = Math.max(0, Math.floor(cx - newW/2));
  const y = Math.max(0, Math.floor(cy - newH*0.65));
  const w = Math.floor(Math.min(newW, (imgEl.naturalWidth||imgEl.width) - x));
  const h = Math.floor(Math.min(newH, (imgEl.naturalHeight||imgEl.height) - y));

  const c = document.createElement('canvas');
  c.width = Math.max(1,w);
  c.height = Math.max(1,h);
  c.getContext('2d').drawImage(imgEl,x,y,w,h,0,0,c.width,c.height);
  return { image:c, rect:{x,y,w,h} };
}

// deterministic-ish seed per face crop, used to pick Potential Calories
function detSeed(rect,imgEl){
  const mix=(h,x)=>(((h^x)>>>0)*16777619)>>>0;
  let h=0x811c9dc5>>>0;
  h=mix(h,rect.x|0);
  h=mix(h,rect.y|0);
  h=mix(h,rect.w|0);
  h=mix(h,rect.h|0);
  h=mix(h,(imgEl.naturalWidth|0));
  h=mix(h,(imgEl.naturalHeight|0));
  return h>>>0;
}

// groupSize -> offset prefix for footer when <5
function calcOffsetPrefix(n){
  if (n === 1) return "80000";
  if (n === 2) return "86000";
  if (n === 3) return "86700";
  if (n === 4) return "86753";
  return "";
}

/*** FACE DETECTION (Cloud Run) ***/
async function imageToBase64NoPrefix(imgEl){
  return new Promise(resolve=>{
    const c = document.createElement('canvas');
    const w = imgEl.naturalWidth  || imgEl.width;
    const h = imgEl.naturalHeight || imgEl.height;
    c.width = w;
    c.height = h;
    c.getContext('2d').drawImage(imgEl,0,0,w,h);
    const dataUrl = c.toDataURL('image/jpeg',0.95);
    const base64 = dataUrl.split(',')[1];
    resolve(base64);
  });
}

async function detectFacesCloud(imgEl){
  const base64Data = await imageToBase64NoPrefix(imgEl);

  console.log("[faces] calling", CLOUD_FUNCTION_URL);
  const res = await fetch(CLOUD_FUNCTION_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ imageBase64: base64Data })
  });

  const text = await res.text();
  if (!res.ok){
    console.error("Cloud Run /detectFaces error", res.status, text);
    throw new Error("Cloud Run call failed");
  }

  let json;
  try { json = JSON.parse(text); }
  catch(e) {
    console.error("Bad JSON from server:", text);
    throw new Error("Bad JSON from server");
  }

  console.log("[faces] got", json);
  const faces = (json.faces || []).slice();
  faces.sort((a,b)=>a.x-b.x); // left->right
  return faces;
}

/*** SIGNED UPLOAD HELPERS (Cloud Run + GCS) ***/

// ask Cloud Run for a temporary signed upload URL for menu_current.pdf
async function getSignedUrlFromCloud(){
  statusMsg("üîê requesting signed upload URL‚Ä¶");
  console.log("[upload] POST", SIGNED_URL_ENDPOINT);

  const res = await fetch(SIGNED_URL_ENDPOINT, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({
      contentType: "application/pdf"
    })
  });

  const txt = await res.text();
  console.log("[upload] signed URL raw response:", res.status, txt);
  statusMsg("signedURL status " + res.status);

  if(!res.ok){
    throw new Error("getSignedUrlFromCloud failed status " + res.status);
  }

  let data;
  try { data = JSON.parse(txt); }
  catch(e){
    console.error("[upload] JSON parse fail on signed URL:", txt);
    throw new Error("Signed URL JSON parse error");
  }

  if (!data.uploadUrl){
    console.error("[upload] no uploadUrl field", data);
    throw new Error("Signed URL missing uploadUrl");
  }

  return data.uploadUrl;
}

// do the actual PUT of the pdf blob to the signed URL
async function uploadToCloudSignedUrl(pdfBlob){
  try {
    statusMsg("üîê getting signed upload URL‚Ä¶");
    const signedUrl = await getSignedUrlFromCloud();
    console.log("[upload] got signedUrl:", signedUrl);

    statusMsg("‚òÅ uploading menu_current.pdf‚Ä¶");

    let putRes;
    try {
      putRes = await fetch(signedUrl, {
        method: "PUT",
        mode: "cors",
        headers: {
          "Content-Type": "application/pdf"
        },
        body: pdfBlob
      });
    } catch(fetchErr) {
      console.error("[upload] fetch() to signedUrl threw before response:", fetchErr);
      statusMsg("‚ö† upload error: browser blocked PUT");
      throw fetchErr;
    }

    console.log("[upload] PUT response:", putRes.status, putRes.statusText);
    statusMsg("PUT status " + putRes.status);

    if (!putRes.ok){
      let bodyText = "(no body)";
      try {
        bodyText = await putRes.text();
      } catch(_) {}
      console.error("[upload] PUT failed body:", bodyText);
      statusMsg("‚ö† upload failed PUT " + putRes.status);
      throw new Error("PUT signedUrl failed " + putRes.status + " " + putRes.statusText + " " + bodyText);
    }

    statusMsg("‚úÖ Menu live at QR link");
  } catch(err){
    console.error("uploadToCloudSignedUrl error", err);
    statusMsg("‚ö† upload error: " + err.message);
  }
}

/*** PUZZLE HELPER LOGIC ***/
function shuffleArray(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/*** POSTER FOOTER LINES ***/
function calcOffsetPrefix(n){
  if (n === 1) return "80000";
  if (n === 2) return "86000";
  if (n === 3) return "86700";
  if (n === 4) return "86753";
  return "";
}

function calcFooterLines(groupSize){
  if (groupSize >= 6){
    return [
      "Ignore any Savory Values of ZERO, that taste is not popular this season.",
      "We suggest not choosing these humanoids."
    ];
  }
  if (groupSize === 5){
    return [];
  }
  const prefix = calcOffsetPrefix(groupSize);
  return [
    "Small lot auctions under 5 Livestock ADD " + prefix + " credits to your desired SAVORY DIGITS"
  ];
}

/*** CANVAS ‚Üí POSTER DRAW ***/
async function drawPoster(slotsForDisplay, groupSize){
  const W=2000, margin=80, cols=2, gapX=28, gapY=32;
  const boxH=520, textAreaH=220, cardH=boxH+textAreaH+110;
  const rows=Math.ceil(slotsForDisplay.length/cols);

  const estCardsBottom = margin+160 + rows*(cardH+gapY);
  const footerSpace = 260;
  const H = Math.max(estCardsBottom + footerSpace, 2600);

  const cellW=(W-margin*2-gapX*(cols-1))/cols;

  const c=document.createElement('canvas');
  c.width=W; c.height=H;
  const ctx=c.getContext('2d');

  // background
  ctx.fillStyle='#fff';
  ctx.fillRect(0,0,W,H);

  // main title
  ctx.fillStyle='#000';
  ctx.font='bold 72px system-ui';
  ctx.textAlign='left';
  ctx.fillText('Galactic Tasting Menu ‚Äî New for Upcoming Harvest!', margin, margin+10);

  // subtitles centered
  ctx.font='32px system-ui';
  ctx.textAlign='center';
  ctx.fillText(
    "Get you events IN ORDER to attend the Galaxy's biggest Humanoid Livestock Auction!",
    W/2,
    margin+70
  );
  ctx.fillText(
    "From SMALL to LARGER, we have everything you need!",
    W/2,
    margin+110
  );

  // draw cards
  ctx.textAlign='left';
  let top=margin+160, idx=0;
  for(let r=0;r<rows;r++){
    let left=margin;
    for(let col=0; col<cols; col++){
      if(idx>=slotsForDisplay.length) break;
      const s=slotsForDisplay[idx++];

      ctx.fillStyle='#f7f7f7';
      roundRect(ctx,left,top,cellW,cardH,22);
      ctx.fill();

      ctx.fillStyle='#000';
      ctx.font='bold 32px system-ui';
      drawWrapped(ctx, s.classTitle, left+24, top+46, cellW-48, 34);

      const img=s.img;
      const boxW=cellW-40, boxY=top+80;
      const scale=Math.min(boxW/img.width, boxH/img.height);
      const w2=img.width*scale, h2=img.height*scale;
      ctx.drawImage(img, left+20+(boxW-w2)/2, boxY+(boxH-h2)/2, w2, h2);

      ctx.font='bold 34px system-ui';
      drawWrapped(ctx, `Lot: ${s.classTitle}`, left+24, boxY+boxH+48, cellW-48, 34);

      ctx.font='30px system-ui';
      drawWrapped(ctx, `Cut: ${s.cutDesc}`, left+24, boxY+boxH+90, cellW-48, 30);

      drawWrapped(ctx, `Savory factor: ${s.savoryWord}`, left+24, boxY+boxH+126, cellW-48, 30);

      drawWrapped(ctx, `Potential Calories (whole): ${fmtNum(s.P)}`, left+24, boxY+boxH+162, cellW-48, 30);

      left += cellW + gapX;
    }
    top += cardH + gapY;
  }

  // footer
  const footerLines = calcFooterLines(groupSize);
  if (footerLines.length){
    let footerY = top + 40;
    ctx.fillStyle='#777';
    ctx.font='26px system-ui';
    ctx.textAlign='left';
    for (let i=0;i<footerLines.length;i++){
      ctx.fillText(footerLines[i], margin, footerY + i*34);
    }
  }

  return c;
}

/*** TEXT / CANVAS UTIL ***/
function drawWrapped(ctx,text,x,y,maxWidth,lineHeight){
  const words=text.split(' ');
  let line='', yy=y;
  for(let n=0;n<words.length;n++){
    const test = line? line+' '+words[n] : words[n];
    const w=ctx.measureText(test).width;
    if(w>maxWidth && n>0){
      ctx.fillText(line,x,yy);
      line=words[n];
      yy+=lineHeight;
    } else {
      line=test;
    }
  }
  if(line) ctx.fillText(line,x,yy);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function fmtNum(n){
  return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

async function canvasToPdfBytes(canvas){
  const { PDFDocument } = PDFLib;
  const pdf = await PDFDocument.create();
  const page = pdf.addPage([canvas.width, canvas.height]);
  const pngBytes = await new Promise(res=>canvas.toBlob(
    b=>b.arrayBuffer().then(res), 'image/png'
  ));
  const png = await pdf.embedPng(pngBytes);
  page.drawImage(png,{x:0,y:0,width:canvas.width,height:canvas.height});
  return await pdf.save();
}

/*** MAIN PIPELINE BUTTON ***/
makeBtn.onclick = async () => {
  try {
    await runPipeline();
  } catch(e){
    console.error("runPipeline error", e);
    alert("Pipeline error. " + e.message);
  }
};

async function runPipeline(){
  if (!snapshotImg){
    alert("Take a photo or choose one first.");
    return;
  }
  await snapshotImg.decode();

  statusMsg("üîç detecting faces‚Ä¶");

  let faces = [];
  try {
    faces = await detectFacesCloud(snapshotImg);
  } catch(e){
    console.error("detectFacesCloud error", e);
  }

  if (!faces || !faces.length){
    statusMsg("‚ö†Ô∏è 0 faces ‚Äî fallback boxes");
    const w=snapshotImg.naturalWidth,h=snapshotImg.naturalHeight;
    const cw=Math.floor(w*0.22),ch=Math.floor(h*0.28);
    const cy=Math.floor((h-ch)/2.2);
    faces=[
      {x:Math.floor(w*0.18),y:cy,w:cw,h:ch},
      {x:Math.floor(w*0.60),y:cy,w:cw,h:ch}
    ];
  } else {
    statusMsg(`üë§ faces: ${faces.length}`);
  }

  setFaces(faces.length);

  // limit to MAX_SLOTS
  const kept = faces.slice(0, MAX_SLOTS);

  // build slot data (crop + calories)
  const slots = kept.map((r,i)=>{
    const cropInfo = cropCentered(snapshotImg,r);
    const seed = detSeed(cropInfo.rect, snapshotImg);
    const P = WHOLE_MIN + (seed % (WHOLE_MAX - WHOLE_MIN + 1)); // Potential Calories (whole)
    return {
      img: cropInfo.image,
      posX: cropInfo.rect.x,
      P,
      savoryDigit: 0,
      classTitle: CLASS_TITLES[i % CLASS_TITLES.length]
    };
  });

  // Sort by Potential Calories ascending
  const orderedByCalories = [...slots].sort((a,b)=> a.P===b.P ? a.posX-b.posX : a.P-b.P);

  // Assign savory digits based on calorie order
  const n = orderedByCalories.length;
  let digits = [];
  if (n>=5){
    // n=5,6,7,8...
    digits = Array(n-5).fill(0).concat(LOCK_DIGITS);
  } else {
    // n=1..4
    digits = LOCK_DIGITS.slice(5-n);
  }
  for (let i=0;i<n;i++) {
    orderedByCalories[i].savoryDigit = digits[i];
  }

  // Show debug puzzle math in UI panel
  const rawInt = parseInt(digits.join(''),10);
  const rawStr = digits.join('');
  rawEl.textContent = rawStr;

  const offsetNum = (LOCK_CODE_5 - rawInt + 100000) % 100000;
  const offsetStr = String(offsetNum).padStart(5,'0');
  offEl.textContent = offsetStr;

  // Build final card info for poster
  const displayCards = orderedByCalories.map((slot, idx) => {
    const savoryWord = SAVORY_NAMES[ slot.savoryDigit % SAVORY_NAMES.length ];
    const lowQuality = (slot.savoryDigit === 0) || (savoryWord === "sweet");

    const cutDesc = lowQuality
      ? CUT_LOW[ idx % CUT_LOW.length ]
      : CUT_PREMIUM[ idx % CUT_PREMIUM.length ];

    return {
      img: slot.img,
      P: slot.P,
      classTitle: slot.classTitle,
      savoryDigit: slot.savoryDigit,
      savoryWord,
      cutDesc
    };
  });

  // Shuffle for PDF so guests still have to arrange SMALL -> LARGER
  const shuffledForDisplay = shuffleArray([...displayCards]);

  // Draw poster (with correct footer text logic)
  const poster = await drawPoster(shuffledForDisplay, n);

  // Make PDF
  let pdfBytes;
  try {
    const { PDFDocument } = PDFLib;
    if (!PDFDocument) throw new Error("no pdf-lib");
    pdfBytes = await canvasToPdfBytes(poster);
  } catch(e){
    console.warn("PDF build error", e);
    alert("PDF failed to build.");
    return;
  }

  // Blob for upload and optional local download
  const blob = new Blob([pdfBytes], {type:"application/pdf"});

  // 1. Upload to bucket through Cloud Run signed URL
  await uploadToCloudSignedUrl(blob);

  // 2. Also save locally for backup/printing
  try {
    const dl = document.createElement("a");
    dl.href = URL.createObjectURL(blob);
    dl.download = "menu_current.pdf";
    dl.click();
  } catch(e){
    console.warn("local download fallback", e);
    const w = window.open();
    const url = poster.toDataURL("image/png");
    w.document.write('<img src="'+url+'" style="width:100%">');
    w.document.close();
    w.focus();
    w.print();
  }
}
</script>
</body>
</html>
