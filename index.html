<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Alien Menu ‚Äî Escape Room Kiosk</title>
<style>
  :root { --border:#ddd; --ink:#000; --muted:#777; --card:#f7f7f7; }
  html,body {
    margin:0; padding:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:#fff;
    color:#000;
  }
  main { padding:16px; max-width:1100px; margin:auto; }
  h2 { margin: 8px 0 12px; }
  #stage {
    position:relative;
  }
  #cam {
    background:#000;
    width:100%;
    max-height:60vh;
    object-fit:cover;
    border-radius:12px;
    display:block;
  }
  #preview {
    background:#000;
    width:100%;
    max-height:60vh;
    object-fit:contain;
    border-radius:12px;
    display:none;
  }
  .row {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin:10px 0;
    align-items:center;
  }
  button {
    padding:10px 14px;
    border-radius:10px;
    border:1px solid #999;
    background:#fff;
    cursor:pointer;
    font-size:16px;
  }
  input[type=file] {
    font-size:14px;
  }
  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
  }
  .banner {
    background:#eef8d6;
    padding:8px 12px;
    border-left:4px solid #79a200;
    border-radius:8px;
    margin:8px 0;
    font-size:14px;
  }
  .panel {
    background:#fafafa;
    border:1px solid var(--border);
    border-radius:10px;
    padding:10px;
    font-size:13px;
  }
  .kv {
    display:grid;
    grid-template-columns: 140px 1fr;
    gap:6px 10px;
    align-items:center;
  }
  .hint {
    color:#666;
    font-size:12px;
    margin-top:-6px
  }
</style>
</head>
<body>
<main>
  <div class="banner" id="status">‚è≥ waiting for camera‚Ä¶</div>
  <h2>Galactic Tasting Menu ‚Äî New for Upcoming Harvest!</h2>

  <div id="stage">
    <video id="cam" playsinline muted></video>
    <img id="preview" alt="snapshot preview"/>
  </div>
  <div class="hint">Line everyone up, fill the frame, then Snap.</div>

  <div class="row">
    <button id="start">Start Camera</button>
    <button id="snap">Snap Photo</button>
    <input type="file" id="file" accept="image/*"/>
    <button id="make">Make PDF + Code</button>
  </div>

  <div class="panel" style="font-size:13px;">
    <div class="kv">
      <div>Image (w√óh)</div><div><span id="dims">‚Äî</span></div>
      <div>Faces found</div><div><span id="faces">‚Äî</span></div>
      <div>Detector</div><div>Cloud Run ‚Üí Vision API</div>
    </div>
  </div>

  <div class="row" style="font-size:14px;">
    <div>RAW digits: <span id="raw" class="mono">‚Äî</span></div>
    <div>Offset: <span id="off" class="mono">‚Äî</span></div>
    <div>Final Lock: <span id="lock" class="mono"><b>86753</b></span></div>
  </div>
</main>

<!-- pdf-lib for PDF export -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

<script>
/*** CONFIG ***/
const CLOUD_FUNCTION_URL = "https://alien-face-service-791433334355.us-east4.run.app/detectFaces";

const LOCK_CODE_5 = 86753; // physical lock code
const LOCK_DIGITS = String(LOCK_CODE_5).padStart(5,'0').split('').map(d=>parseInt(d,10));

// max faces on menu
const MAX_SLOTS   = 8;

// Potential Calories (whole body) range
const WHOLE_MIN   = 80000;
const WHOLE_MAX   = 220000;

// flavor labels used for "Savory factor"
const SAVORY_NAMES = [
  "sweet","tangy","smoky","zesty","umami",
  "peppery","citrusy","herbal","earthy","bright"
];

// stock titles
const CLASS_TITLES = [
  "Feeder Humanoid","Commercial Feeder","Humanoid Rare Stock",
  "Choice Stock","Prime Stock","Select Stock",
  "Market Class","Premium Consignment"
];

// nice / premium cut language pool
const CUT_PREMIUM = [
  "tender with marbled highlights",
  "fine-grained and evenly marbled",
  "velvety texture and balanced richness",
  "hearty cut with deep, developed flavor",
  "silky finish, smooth bite",
  "supple grain and well-rounded body flavor",
  "mellow body texture, easy carving",
  "full profile and satisfying density",
  "rich-bodied, classic table cut",
  "stable house cut with predictable yield"
];

// lower quality / stew / filler cut pool
const CUT_LOW = [
  "chewy filler meat, bulk-grade protein",
  "dense frame cut, best simmered for hours",
  "workable stew stock, reliable mass",
  "tough body sections, economical in volume",
  "slow-braise material, pantry extender",
  "utility trim cut, broth-friendly portions",
  "assertive chew, thrifty slow-cook potential",
  "marrow-forward frame meat for group stew",
  "hearty bone-adjacent texture, communal pot use",
  "rugged cut, recommended for stew service"
];

/*** DOM refs ***/
const statusEl = document.getElementById('status');
const video    = document.getElementById('cam');
const preview  = document.getElementById('preview');
const startBtn = document.getElementById('start');
const snapBtn  = document.getElementById('snap');
const fileIn   = document.getElementById('file');
const makeBtn  = document.getElementById('make');

const dimsEl   = document.getElementById('dims');
const facesEl  = document.getElementById('faces');

const rawEl    = document.getElementById('raw');
const offEl    = document.getElementById('off');
const lockEl   = document.getElementById('lock');
lockEl.textContent = String(LOCK_CODE_5).padStart(5,'0');

/*** State ***/
let snapshotImg = null;

/*** Helpers ***/
function statusMsg(m){ statusEl.textContent = m; console.log("[status]",m); }
function setDims(w,h){ dimsEl.textContent = `${w}√ó${h}`; }
function setFaces(n){ facesEl.textContent = String(n); }

/*** Camera / file load ***/
startBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment',
        width:  { ideal: 1280 },
        height: { ideal: 1280 }
      },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    preview.style.display='none';
    video.style.display='block';
    statusMsg('üé• camera ready');
  } catch(e){
    console.error("getUserMedia error", e);
    alert('Camera blocked. Use HTTPS or localhost on the device.');
  }
};

snapBtn.onclick = () => {
  if (!video.srcObject) {
    console.warn("snap: no video stream");
    return;
  }
  const c = document.createElement('canvas');
  const W = video.videoWidth;
  const H = video.videoHeight;
  c.width = W;
  c.height = H;
  c.getContext('2d').drawImage(video,0,0,W,H);
  preview.src = c.toDataURL('image/jpeg',0.95);

  snapshotImg = new Image();
  snapshotImg.onload = ()=>{
    setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
  };
  snapshotImg.src = preview.src;

  video.style.display='none';
  preview.style.display='block';
};

fileIn.onchange = e => {
  const f = e.target.files[0];
  if(!f) {
    console.warn("file input: no file");
    return;
  }
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    const c = document.createElement('canvas');
    c.width  = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext('2d').drawImage(img,0,0);
    preview.src = c.toDataURL('image/jpeg',0.95);

    snapshotImg = new Image();
    snapshotImg.onload = ()=>{
      setDims(snapshotImg.naturalWidth,snapshotImg.naturalHeight);
    };
    snapshotImg.src = preview.src;

    video.style.display='none';
    preview.style.display='block';
  };
  img.src = url;
};

/*** Vision call through Cloud Run ***/
async function imageToBase64NoPrefix(imgEl){
  return new Promise(resolve=>{
    const c = document.createElement('canvas');
    const w = imgEl.naturalWidth  || imgEl.width;
    const h = imgEl.naturalHeight || imgEl.height;
    c.width = w;
    c.height = h;
    c.getContext('2d').drawImage(imgEl,0,0,w,h);
    const dataUrl = c.toDataURL('image/jpeg',0.95);
    const base64 = dataUrl.split(',')[1];
    resolve(base64);
  });
}

async function detectFacesCloud(imgEl){
  const base64Data = await imageToBase64NoPrefix(imgEl);

  const res = await fetch(CLOUD_FUNCTION_URL, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ imageBase64: base64Data })
  });

  const text = await res.text();
  if (!res.ok){
    console.error("Cloud Run error", res.status, text);
    throw new Error("Cloud Run call failed");
  }

  let json;
  try { json = JSON.parse(text); }
  catch(e) { throw new Error("Bad JSON from server"); }

  const faces = (json.faces || []).slice();
  faces.sort((a,b)=>a.x-b.x); // left->right
  return faces;
}

/*** Main pipeline ***/
makeBtn.onclick = async () => {
  try {
    await runPipeline();
  } catch(e){
    console.error("runPipeline error", e);
    alert("Pipeline error. " + e.message);
  }
};

async function runPipeline(){
  if (!snapshotImg){
    alert("Take a photo or choose one first.");
    return;
  }
  await snapshotImg.decode();

  statusMsg("üîç detecting faces‚Ä¶");

  let faces = [];
  try {
    faces = await detectFacesCloud(snapshotImg);
  } catch(e){
    console.error("detectFacesCloud error", e);
  }

  if (!faces || !faces.length){
    statusMsg("‚ö†Ô∏è 0 faces ‚Äî fallback boxes");
    const w=snapshotImg.naturalWidth,h=snapshotImg.naturalHeight;
    const cw=Math.floor(w*0.22),ch=Math.floor(h*0.28);
    const cy=Math.floor((h-ch)/2.2);
    faces=[
      {x:Math.floor(w*0.18),y:cy,w:cw,h:ch},
      {x:Math.floor(w*0.60),y:cy,w:cw,h:ch}
    ];
  } else {
    statusMsg(`üë§ faces: ${faces.length}`);
  }

  setFaces(faces.length);

  // limit to MAX_SLOTS
  const kept = faces.slice(0, MAX_SLOTS);

  // build slot data (crop + calories)
  const slots = kept.map((r,i)=>{
    const cropInfo = cropCentered(snapshotImg,r);
    const seed = detSeed(cropInfo.rect, snapshotImg);
    const P = WHOLE_MIN + (seed % (WHOLE_MAX - WHOLE_MIN + 1)); // Potential Calories (whole)
    return {
      img: cropInfo.image,
      posX: cropInfo.rect.x,
      P,
      savoryDigit: 0, // will fill in later
      classTitle: CLASS_TITLES[i % CLASS_TITLES.length]
    };
  });

  // Sort (true size order) by Potential Calories ascending
  const orderedByCalories = [...slots].sort((a,b)=> a.P===b.P ? a.posX-b.posX : a.P-b.P);

  // Assign savory digits based on calorie order so puzzle math is stable
  const n = orderedByCalories.length;
  let digits = [];
  if (n>=5){
    // pad front with zeros if >5, then lock digits at end
    digits = Array(n-5).fill(0).concat(LOCK_DIGITS);
  } else {
    // take the last n digits of LOCK_CODE_5
    digits = LOCK_DIGITS.slice(5-n);
  }
  for (let i=0;i<n;i++) {
    orderedByCalories[i].savoryDigit = digits[i];
  }

  // Compute base puzzle math
  const rawInt = parseInt(digits.join(''),10);
  const rawStr = digits.join('');
  rawEl.textContent = rawStr;

  const offsetNum = (LOCK_CODE_5 - rawInt + 100000) % 100000;
  const offsetStr = String(offsetNum).padStart(5,'0');
  offEl.textContent = offsetStr;

  // Now build final card objects for display
  // We'll attach the savory word and the cut description,
  // with special handling if savoryDigit === 0 OR savory word is "sweet".
  const displayCards = orderedByCalories.map((slot, idx) => {
    const savoryWord = SAVORY_NAMES[ slot.savoryDigit % SAVORY_NAMES.length ];
    const lowQuality = (slot.savoryDigit === 0) || (savoryWord === "sweet");

    const cutDesc = lowQuality
      ? CUT_LOW[ idx % CUT_LOW.length ]
      : CUT_PREMIUM[ idx % CUT_PREMIUM.length ];

    return {
      img: slot.img,
      P: slot.P,
      classTitle: slot.classTitle,
      savoryDigit: slot.savoryDigit,
      savoryWord,
      cutDesc
    };
  });

  // Shuffle for the PDF so guests still have to arrange SMALL -> LARGER
  const shuffledForDisplay = shuffleArray([...displayCards]);

  // Draw the poster (footer now sits right AFTER cards, with padding)
  const poster = await drawPoster(shuffledForDisplay, n);

  // Generate PDF bytes
  let pdfBytes;
  try {
    const { PDFDocument } = PDFLib;
    if (!PDFDocument) throw new Error("no pdf-lib");
    pdfBytes = await canvasToPdfBytes(poster);
  } catch(e){
    console.warn("PDF build error", e);
    alert("PDF failed to build.");
    return;
  }

  // Make a blob for local use + Wix upload
  const blob = new Blob([pdfBytes], {type:"application/pdf"});

  // üöÄ Upload automatically to Wix
  await uploadToWix(blob);

  // Also download locally (backup / printing if you want)
  try {
    const dl = document.createElement("a");
    dl.href = URL.createObjectURL(blob);
    dl.download = "menu_current.pdf";
    dl.click();
  } catch(e){
    console.warn("local download fallback", e);
    const w = window.open();
    const url = poster.toDataURL("image/png");
    w.document.write('<img src="'+url+'" style="width:100%">');
    w.document.close();
    w.focus();
    w.print();
  }
}

/*** WIX UPLOAD SECTION ***/
async function uploadToWix(pdfBlob){
  try {
    console.log("Uploading menu_current.pdf to Wix‚Ä¶");

    // 1. Ask Wix backend for a signed upload URL.
    // IMPORTANT:
    // You must create /backend/http-functions.js on Wix with post_getSignedUploadUrl (see below)
    const WIX_FUNCTION_URL = "https://www.canuxcape.com/_functions/getSignedUploadUrl";

    const metaRes = await fetch(WIX_FUNCTION_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        fileName: "current_menu.pdf",
        fileSize: pdfBlob.size,
        mimeType: "application/pdf"
      })
    });

    const { uploadUrl, error } = await metaRes.json();
    if (error || !uploadUrl) {
      console.error("‚ùå Could not get signed upload URL:", error);
      statusMsg("‚ö†Ô∏è Upload URL error");
      return;
    }

    // 2. Upload directly to Wix Media via signed URL
    const putRes = await fetch(uploadUrl, {
      method: "PUT",
      headers: { "Content-Type": "application/pdf" },
      body: pdfBlob
    });

    if (!putRes.ok) {
      console.error("‚ùå Wix upload failed:", putRes.status, putRes.statusText);
      statusMsg("‚ö†Ô∏è Upload failed");
      return;
    }

    console.log("‚úÖ Uploaded to Wix successfully!");
    statusMsg("‚úÖ Menu live on canuxcape.com/menu_current");
  } catch(err){
    console.error("‚ùå uploadToWix error", err);
    statusMsg("‚ö†Ô∏è Upload exception");
  }
}
/*** END WIX UPLOAD SECTION ***/

/*** helpers ***/
function shuffleArray(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function cropCentered(imgEl, faceRect){
  // expand detection box to include shoulders
  const cx = faceRect.x + faceRect.w/2;
  const cy = faceRect.y + faceRect.h/2;
  const newW = faceRect.w * 2.0;
  const newH = faceRect.h * 2.2;
  const x = Math.max(0, Math.floor(cx - newW/2));
  const y = Math.max(0, Math.floor(cy - newH*0.65));
  const w = Math.floor(Math.min(newW, (imgEl.naturalWidth||imgEl.width) - x));
  const h = Math.floor(Math.min(newH, (imgEl.naturalHeight||imgEl.height) - y));

  const c = document.createElement('canvas');
  c.width = Math.max(1,w);
  c.height = Math.max(1,h);
  c.getContext('2d').drawImage(imgEl,x,y,w,h,0,0,c.width,c.height);
  return { image:c, rect:{x,y,w,h} };
}

function detSeed(rect,imgEl){
  const mix=(h,x)=>(((h^x)>>>0)*16777619)>>>0;
  let h=0x811c9dc5>>>0;
  h=mix(h,rect.x|0);
  h=mix(h,rect.y|0);
  h=mix(h,rect.w|0);
  h=mix(h,rect.h|0);
  h=mix(h,(imgEl.naturalWidth|0));
  h=mix(h,(imgEl.naturalHeight|0));
  return h>>>0;
}

async function drawPoster(slotsForDisplay, groupSize){
  // Layout constants
  const W=2000, margin=80, cols=2, gapX=28, gapY=32;
  const boxH=520, textAreaH=220, cardH=boxH+textAreaH+110;
  const rows=Math.ceil(slotsForDisplay.length/cols);

  // We don't know final H yet because we want footer right below cards.
  // We'll estimate height big enough:
  const estCardsBottom = margin+160 + rows*(cardH+gapY);
  const footerSpace = 200;
  const H = Math.max(estCardsBottom + footerSpace, 2600);

  const cellW=(W-margin*2-gapX*(cols-1))/cols;

  const c=document.createElement('canvas');
  c.width=W; c.height=H;
  const ctx=c.getContext('2d');

  // background
  ctx.fillStyle='#fff';
  ctx.fillRect(0,0,W,H);

  // main title
  ctx.fillStyle='#000';
  ctx.font='bold 72px system-ui';
  ctx.textAlign='left';
  ctx.fillText('Galactic Tasting Menu ‚Äî New for Upcoming Harvest!', margin, margin+10);

  // subtitles centered
  ctx.font='32px system-ui';
  ctx.textAlign='center';
  ctx.fillText(
    "Get you events IN ORDER to attend the Galaxy's biggest Humanoid Livestock Auction!",
    W/2,
    margin+70
  );
  ctx.fillText(
    "From SMALL to LARGER, we have everything you need!",
    W/2,
    margin+110
  );

  // draw cards
  ctx.textAlign='left';
  let top=margin+160, idx=0;
  for(let r=0;r<rows;r++){
    let left=margin;
    for(let col=0; col<cols; col++){
      if(idx>=slotsForDisplay.length) break;
      const s=slotsForDisplay[idx++];

      ctx.fillStyle='#f7f7f7';
      roundRect(ctx,left,top,cellW,cardH,22);
      ctx.fill();

      ctx.fillStyle='#000';
      ctx.font='bold 32px system-ui';
      drawWrapped(ctx, s.classTitle, left+24, top+46, cellW-48, 34);

      const img=s.img;
      const boxW=cellW-40, boxY=top+80;
      const scale=Math.min(boxW/img.width, boxH/img.height);
      const w2=img.width*scale, h2=img.height*scale;
      ctx.drawImage(img, left+20+(boxW-w2)/2, boxY+(boxH-h2)/2, w2, h2);

      ctx.font='bold 34px system-ui';
      drawWrapped(ctx, `Lot: ${s.classTitle}`, left+24, boxY+boxH+48, cellW-48, 34);

      ctx.font='30px system-ui';
      drawWrapped(ctx, `Cut: ${s.cutDesc}`, left+24, boxY+boxH+90, cellW-48, 30);

      drawWrapped(ctx, `Savory factor: ${s.savoryWord}`, left+24, boxY+boxH+126, cellW-48, 30);

      drawWrapped(ctx, `Potential Calories (whole): ${fmtNum(s.P)}`, left+24, boxY+boxH+162, cellW-48, 30);

      left += cellW + gapX;
    }
    top += cardH + gapY;
  }

  // now "top" is just after the last row of cards.
  // We'll add footer text ~40px lower so it has nice breathing room.
  let footerY = top + 40;
  ctx.fillStyle='#777';
  ctx.font='26px system-ui';
  ctx.textAlign='left';

  if (groupSize < 6){
    ctx.fillText(
      "Small lot auctions under 6 Livestock ADD 86000 credits to your desired SAVORY DIGITS",
      margin,
      footerY
    );
  } else {
    ctx.fillText(
      "Ignore any Savory Values of ZERO, that taste is not popular this season.",
      margin,
      footerY
    );
    ctx.fillText(
      "We suggest not choosing these humanoids.",
      margin,
      footerY + 34
    );
  }

  return c;
}

function drawWrapped(ctx,text,x,y,maxWidth,lineHeight){
  const words=text.split(' ');
  let line='', yy=y;
  for(let n=0;n<words.length;n++){
    const test = line? line+' '+words[n] : words[n];
    const w=ctx.measureText(test).width;
    if(w>maxWidth && n>0){
      ctx.fillText(line,x,yy);
      line=words[n];
      yy+=lineHeight;
    } else {
      line=test;
    }
  }
  if(line) ctx.fillText(line,x,yy);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function fmtNum(n){
  return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

async function canvasToPdfBytes(canvas){
  const { PDFDocument } = PDFLib;
  const pdf = await PDFDocument.create();
  const page = pdf.addPage([canvas.width, canvas.height]);
  const pngBytes = await new Promise(res=>canvas.toBlob(
    b=>b.arrayBuffer().then(res), 'image/png'
  ));
  const png = await pdf.embedPng(pngBytes);
  page.drawImage(png,{x:0,y:0,width:canvas.width,height:canvas.height});
  return await pdf.save();
}
</script>
</body>
</html>
